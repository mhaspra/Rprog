---
title: "Subsetting"
output: html_document
---

##Subsetting with []
Always returns an object of the same class as the original (Except for getting one elemt out of a matrix):

###Subsetting vectors
```{r}
chars <- c("a", "b", "c", "d", "a", "b") # create a char vector
chars
chars[2] # extract a single element
chars[2:4] # extract a bunch of elements by a numerical index-vector
chars[chars == "b"] # extract an element by a boolean vector
booleanVector <- chars == "b" # the boolean vector that is generated by the expression before
booleanVector
chars[booleanVector] # the same as above
```
###Subsetting matrices
```{r}
mat <- matrix(1:6, 3, 2) # create a 3x2 matrix
mat
mat[1,1] # get element of upper left corner (returns a vector of lenght 1!)
mat[3,2] # get element of lower right corner (returns a vector of lenght 1!)
mat[3,2, drop = FALSE] # get element of lower right corner. But do not drop the dimension, return a 1x1 matrix.
mat[,1] # get first column as vector
mat[,1, drop = FALSE] # get first column as 3x1 matrix
mat[3,] # get last row
```
##Subsetting with [[]] and $
[[]] is used to extract elements of a list or dataframe. Only extracts a single element. $ is used to extract elements that have names

###Subsetting lists
```{r}
l <- list(1L, 2, 3+3i, "d", as.factor("e"), 1:4) # create a list.
names(l) <- c("int", "num", "complex", "char", "factor", "vector") # add names to the elements
l
l[[1]] # get first element
l[1] # get firs list entry
l[["factor"]] # get element by name
l$factor # get element by name
l[1:3] # get the first three elements (again returns a list)
l[[c(6,3)]] # recursively subsetting into the sixth element and getting the third of it
```
#### Partial matching
```{r}
l <- list(alongname = "a value")
l$alon # the $ operator can partially match a name of a list element.
l[["al", exact = FALSE]] # the double-bracket operator too
```
#### Removing NA values
```{r}
vec <- c(1, 2, NA, 4, NA, NaN)
vec[!is.na(vec)] # create a boolean vector and subsett the vector with it, remember NaN is Na
```
#### complete.cases

```{r}
vecInt <- c(1, 2, NA, 4, NA, NaN)
vecChar <- c("a", "b", NA, NA, NA, NA)
complete.cases(vecInt, vecChar) # generate a boolean vector that is only true where both vectors have values

df <- data.frame(vecInt, vecChar) # create a dataframe
df
df[complete.cases(df),] # only get rows without NA values
```